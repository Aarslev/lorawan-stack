// Copyright Â© 2019 The Things Industries B.V.

syntax = "proto3";

package tti.lorawan.v3;

import "github.com/envoyproxy/protoc-gen-validate/validate/validate.proto";
import "github.com/gogo/protobuf/gogoproto/gogo.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";
import "lorawan-stack/api/enums.proto";
import "lorawan-stack/api/tti/identifiers.proto";

option go_package = "go.thethings.network/lorawan-stack/pkg/ttipb";

message License {
  // Immutable and unique public identifier for the API key.
  // Generated by the License Server.
  LicenseIdentifiers id = 1 [(gogoproto.embed) = true, (gogoproto.nullable) = false, (validate.rules).message.required = true];

  // Issuer of the license.
  LicenseIssuerIdentifiers license_issuer_ids = 2 [(gogoproto.embed) = true, (gogoproto.nullable) = false, (validate.rules).message.required = true];

  google.protobuf.Timestamp created_at = 3 [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];
  // The license is not valid before this time.
  google.protobuf.Timestamp valid_from = 4 [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];
  // The license is not valid after this time.
  google.protobuf.Timestamp valid_until = 5 [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];

  // For how long (before valid_until) to warn about license expiry.
  google.protobuf.Duration warn_for = 6 [(gogoproto.nullable) = false, (gogoproto.stdduration) = true];
  // For how long (before valid_until) to limit non-critical functionality.
  google.protobuf.Duration limit_for = 7 [(gogoproto.nullable) = false, (gogoproto.stdduration) = true];

  // If set, only the given components can be started.
  repeated ttn.lorawan.v3.ClusterRole components = 8;

  // If set, the server addresses must match any of these regexps.
  repeated string address_regexps = 9;
  // If set, the configured DevAddr prefixes must match any of these prefixes.
  repeated bytes dev_addr_prefixes = 10 [(gogoproto.customtype) = "go.thethings.network/lorawan-stack/pkg/types.DevAddrPrefix", (gogoproto.nullable) = false];
  // If set, the configured JoinEUI prefixes must match any of these prefixes.
  repeated bytes join_eui_prefixes = 11 [(gogoproto.customtype) = "go.thethings.network/lorawan-stack/pkg/types.EUI64Prefix", (gogoproto.nullable) = false];

  // Indicates whether multi-tenancy support is included.
  bool multi_tenancy = 12;

  // If set, restricts the maximum number of applications that can be created.
  google.protobuf.UInt64Value max_applications = 13;
  // If set, restricts the maximum number of clients that can be created.
  google.protobuf.UInt64Value max_clients = 14;
  // If set, restricts the maximum number of end_devices that can be created.
  google.protobuf.UInt64Value max_end_devices = 15;
  // If set, restricts the maximum number of gateways that can be created.
  google.protobuf.UInt64Value max_gateways = 16;
  // If set, restricts the maximum number of organizations that can be created.
  google.protobuf.UInt64Value max_organizations = 17;
  // If set, restricts the maximum number of users that can be created.
  google.protobuf.UInt64Value max_users = 18;

  // If set, requires checking in with a metering service.
  MeteringConfiguration metering = 19;
}

message LicenseUpdate {
  // How long the license validity should be extended (relative to the current time) on update.
  google.protobuf.Duration valid_until = 1;
}

message MeteringConfiguration {
  // How frequently to report to the metering service.
  google.protobuf.Duration interval = 1;
  // How to update the license on success.
  LicenseUpdate on_success = 2;

  message AWS {
    string sku = 1 [(gogoproto.customname) = "SKU"];
  }
  oneof metering {
    AWS aws = 3;
  }
}

message LicenseKey {
  // The marshaled License message.
  bytes license = 1;

  message Signature {
    // The ID of the key used to sign license.
    string key_id = 1 [(gogoproto.customname) = "KeyID"];
    // Signature for license using the key identified by key_id.
    bytes signature = 2;
  }

  // Signatures for the license bytes. The LicenseKey is invalid if it does not
  // contain any signature with a known key_id or if it contains any invalid
  // signature.
  repeated Signature signatures = 2;
}

message MeteringData {
  // TODO: TenantRegistryTotals totals = 1; (https://github.com/TheThingsIndustries/lorawan-stack/pull/1696)
}
