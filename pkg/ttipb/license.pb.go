// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lorawan-stack/api/tti/license.proto

package ttipb

import (
	bytes "bytes"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
	time "time"

	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	ttnpb "go.thethings.network/lorawan-stack/pkg/ttnpb"
	go_thethings_network_lorawan_stack_pkg_types "go.thethings.network/lorawan-stack/pkg/types"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type License struct {
	// Immutable and unique public identifier for the License.
	// Generated by the License Server.
	LicenseIdentifiers `protobuf:"bytes,1,opt,name=id,proto3,embedded=id" json:"id"`
	// Issuer of the license.
	LicenseIssuerIdentifiers `protobuf:"bytes,2,opt,name=license_issuer_ids,json=licenseIssuerIds,proto3,embedded=license_issuer_ids" json:"license_issuer_ids"`
	CreatedAt                time.Time `protobuf:"bytes,3,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at"`
	// The license is not valid before this time.
	ValidFrom time.Time `protobuf:"bytes,4,opt,name=valid_from,json=validFrom,proto3,stdtime" json:"valid_from"`
	// The license is not valid after this time.
	ValidUntil time.Time `protobuf:"bytes,5,opt,name=valid_until,json=validUntil,proto3,stdtime" json:"valid_until"`
	// For how long (before valid_until) to warn about license expiry.
	WarnFor time.Duration `protobuf:"bytes,6,opt,name=warn_for,json=warnFor,proto3,stdduration" json:"warn_for"`
	// For how long (before valid_until) to limit non-critical functionality.
	LimitFor time.Duration `protobuf:"bytes,7,opt,name=limit_for,json=limitFor,proto3,stdduration" json:"limit_for"`
	// If set, sets the minimum version allowed by this license (major.minor.patch).
	MinVersion string `protobuf:"bytes,8,opt,name=min_version,json=minVersion,proto3" json:"min_version,omitempty"`
	// If set, sets the maximum version allowed by this license (major.minor.patch).
	MaxVersion string `protobuf:"bytes,9,opt,name=max_version,json=maxVersion,proto3" json:"max_version,omitempty"`
	// If set, only the given components can be started.
	Components []ttnpb.ClusterRole `protobuf:"varint,10,rep,packed,name=components,proto3,enum=ttn.lorawan.v3.ClusterRole" json:"components,omitempty"`
	// If set, the server addresses must match any of these regexps.
	ComponentAddressRegexps []string `protobuf:"bytes,11,rep,name=component_address_regexps,json=componentAddressRegexps,proto3" json:"component_address_regexps,omitempty"`
	// If set, the configured DevAddr prefixes must match any of these prefixes.
	DevAddrPrefixes []go_thethings_network_lorawan_stack_pkg_types.DevAddrPrefix `protobuf:"bytes,12,rep,name=dev_addr_prefixes,json=devAddrPrefixes,proto3,customtype=go.thethings.network/lorawan-stack/pkg/types.DevAddrPrefix" json:"dev_addr_prefixes"`
	// If set, the configured JoinEUI prefixes must match any of these prefixes.
	JoinEUIPrefixes []go_thethings_network_lorawan_stack_pkg_types.EUI64Prefix `protobuf:"bytes,13,rep,name=join_eui_prefixes,json=joinEuiPrefixes,proto3,customtype=go.thethings.network/lorawan-stack/pkg/types.EUI64Prefix" json:"join_eui_prefixes"`
	// Indicates whether multi-tenancy support is included.
	MultiTenancy bool `protobuf:"varint,14,opt,name=multi_tenancy,json=multiTenancy,proto3" json:"multi_tenancy,omitempty"`
	// If set, restricts the maximum number of applications that can be created.
	MaxApplications *types.UInt64Value `protobuf:"bytes,15,opt,name=max_applications,json=maxApplications,proto3" json:"max_applications,omitempty"`
	// If set, restricts the maximum number of clients that can be created.
	MaxClients *types.UInt64Value `protobuf:"bytes,16,opt,name=max_clients,json=maxClients,proto3" json:"max_clients,omitempty"`
	// If set, restricts the maximum number of end_devices that can be created.
	MaxEndDevices *types.UInt64Value `protobuf:"bytes,17,opt,name=max_end_devices,json=maxEndDevices,proto3" json:"max_end_devices,omitempty"`
	// If set, restricts the maximum number of gateways that can be created.
	MaxGateways *types.UInt64Value `protobuf:"bytes,18,opt,name=max_gateways,json=maxGateways,proto3" json:"max_gateways,omitempty"`
	// If set, restricts the maximum number of organizations that can be created.
	MaxOrganizations *types.UInt64Value `protobuf:"bytes,19,opt,name=max_organizations,json=maxOrganizations,proto3" json:"max_organizations,omitempty"`
	// If set, restricts the maximum number of users that can be created.
	MaxUsers *types.UInt64Value `protobuf:"bytes,20,opt,name=max_users,json=maxUsers,proto3" json:"max_users,omitempty"`
	// If set, requires checking in with a metering service.
	Metering             *MeteringConfiguration `protobuf:"bytes,21,opt,name=metering,proto3" json:"metering,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *License) Reset()      { *m = License{} }
func (*License) ProtoMessage() {}
func (*License) Descriptor() ([]byte, []int) {
	return fileDescriptor_09ba50819c0c2e19, []int{0}
}
func (m *License) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *License) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_License.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *License) XXX_Merge(src proto.Message) {
	xxx_messageInfo_License.Merge(m, src)
}
func (m *License) XXX_Size() int {
	return m.Size()
}
func (m *License) XXX_DiscardUnknown() {
	xxx_messageInfo_License.DiscardUnknown(m)
}

var xxx_messageInfo_License proto.InternalMessageInfo

func (m *License) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *License) GetValidFrom() time.Time {
	if m != nil {
		return m.ValidFrom
	}
	return time.Time{}
}

func (m *License) GetValidUntil() time.Time {
	if m != nil {
		return m.ValidUntil
	}
	return time.Time{}
}

func (m *License) GetWarnFor() time.Duration {
	if m != nil {
		return m.WarnFor
	}
	return 0
}

func (m *License) GetLimitFor() time.Duration {
	if m != nil {
		return m.LimitFor
	}
	return 0
}

func (m *License) GetMinVersion() string {
	if m != nil {
		return m.MinVersion
	}
	return ""
}

func (m *License) GetMaxVersion() string {
	if m != nil {
		return m.MaxVersion
	}
	return ""
}

func (m *License) GetComponents() []ttnpb.ClusterRole {
	if m != nil {
		return m.Components
	}
	return nil
}

func (m *License) GetComponentAddressRegexps() []string {
	if m != nil {
		return m.ComponentAddressRegexps
	}
	return nil
}

func (m *License) GetMultiTenancy() bool {
	if m != nil {
		return m.MultiTenancy
	}
	return false
}

func (m *License) GetMaxApplications() *types.UInt64Value {
	if m != nil {
		return m.MaxApplications
	}
	return nil
}

func (m *License) GetMaxClients() *types.UInt64Value {
	if m != nil {
		return m.MaxClients
	}
	return nil
}

func (m *License) GetMaxEndDevices() *types.UInt64Value {
	if m != nil {
		return m.MaxEndDevices
	}
	return nil
}

func (m *License) GetMaxGateways() *types.UInt64Value {
	if m != nil {
		return m.MaxGateways
	}
	return nil
}

func (m *License) GetMaxOrganizations() *types.UInt64Value {
	if m != nil {
		return m.MaxOrganizations
	}
	return nil
}

func (m *License) GetMaxUsers() *types.UInt64Value {
	if m != nil {
		return m.MaxUsers
	}
	return nil
}

func (m *License) GetMetering() *MeteringConfiguration {
	if m != nil {
		return m.Metering
	}
	return nil
}

type LicenseUpdate struct {
	// How long the license validity should be extended (relative to the current time) on update.
	ExtendValidUntil     *time.Duration `protobuf:"bytes,1,opt,name=extend_valid_until,json=extendValidUntil,proto3,stdduration" json:"extend_valid_until,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *LicenseUpdate) Reset()      { *m = LicenseUpdate{} }
func (*LicenseUpdate) ProtoMessage() {}
func (*LicenseUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_09ba50819c0c2e19, []int{1}
}
func (m *LicenseUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LicenseUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LicenseUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LicenseUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LicenseUpdate.Merge(m, src)
}
func (m *LicenseUpdate) XXX_Size() int {
	return m.Size()
}
func (m *LicenseUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_LicenseUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_LicenseUpdate proto.InternalMessageInfo

func (m *LicenseUpdate) GetExtendValidUntil() *time.Duration {
	if m != nil {
		return m.ExtendValidUntil
	}
	return nil
}

type MeteringConfiguration struct {
	// How frequently to report to the metering service.
	Interval time.Duration `protobuf:"bytes,1,opt,name=interval,proto3,stdduration" json:"interval"`
	// How to update the license on success.
	OnSuccess *LicenseUpdate `protobuf:"bytes,2,opt,name=on_success,json=onSuccess,proto3" json:"on_success,omitempty"`
	// Types that are valid to be assigned to Metering:
	//	*MeteringConfiguration_AWS_
	Metering             isMeteringConfiguration_Metering `protobuf_oneof:"metering"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *MeteringConfiguration) Reset()      { *m = MeteringConfiguration{} }
func (*MeteringConfiguration) ProtoMessage() {}
func (*MeteringConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_09ba50819c0c2e19, []int{2}
}
func (m *MeteringConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeteringConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeteringConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeteringConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeteringConfiguration.Merge(m, src)
}
func (m *MeteringConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *MeteringConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_MeteringConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_MeteringConfiguration proto.InternalMessageInfo

type isMeteringConfiguration_Metering interface {
	isMeteringConfiguration_Metering()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type MeteringConfiguration_AWS_ struct {
	AWS *MeteringConfiguration_AWS `protobuf:"bytes,3,opt,name=aws,proto3,oneof"`
}

func (*MeteringConfiguration_AWS_) isMeteringConfiguration_Metering() {}

func (m *MeteringConfiguration) GetMetering() isMeteringConfiguration_Metering {
	if m != nil {
		return m.Metering
	}
	return nil
}

func (m *MeteringConfiguration) GetInterval() time.Duration {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *MeteringConfiguration) GetOnSuccess() *LicenseUpdate {
	if m != nil {
		return m.OnSuccess
	}
	return nil
}

func (m *MeteringConfiguration) GetAWS() *MeteringConfiguration_AWS {
	if x, ok := m.GetMetering().(*MeteringConfiguration_AWS_); ok {
		return x.AWS
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MeteringConfiguration) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MeteringConfiguration_AWS_)(nil),
	}
}

type MeteringConfiguration_AWS struct {
	SKU                  string   `protobuf:"bytes,1,opt,name=sku,proto3" json:"sku,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MeteringConfiguration_AWS) Reset()      { *m = MeteringConfiguration_AWS{} }
func (*MeteringConfiguration_AWS) ProtoMessage() {}
func (*MeteringConfiguration_AWS) Descriptor() ([]byte, []int) {
	return fileDescriptor_09ba50819c0c2e19, []int{2, 0}
}
func (m *MeteringConfiguration_AWS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeteringConfiguration_AWS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeteringConfiguration_AWS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeteringConfiguration_AWS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeteringConfiguration_AWS.Merge(m, src)
}
func (m *MeteringConfiguration_AWS) XXX_Size() int {
	return m.Size()
}
func (m *MeteringConfiguration_AWS) XXX_DiscardUnknown() {
	xxx_messageInfo_MeteringConfiguration_AWS.DiscardUnknown(m)
}

var xxx_messageInfo_MeteringConfiguration_AWS proto.InternalMessageInfo

func (m *MeteringConfiguration_AWS) GetSKU() string {
	if m != nil {
		return m.SKU
	}
	return ""
}

type LicenseKey struct {
	// The marshaled License message.
	License []byte `protobuf:"bytes,1,opt,name=license,proto3" json:"license,omitempty"`
	// Signatures for the license bytes. The LicenseKey is invalid if it does not
	// contain any signature with a known key_id or if it contains any invalid
	// signature.
	Signatures           []*LicenseKey_Signature `protobuf:"bytes,2,rep,name=signatures,proto3" json:"signatures,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *LicenseKey) Reset()      { *m = LicenseKey{} }
func (*LicenseKey) ProtoMessage() {}
func (*LicenseKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_09ba50819c0c2e19, []int{3}
}
func (m *LicenseKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LicenseKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LicenseKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LicenseKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LicenseKey.Merge(m, src)
}
func (m *LicenseKey) XXX_Size() int {
	return m.Size()
}
func (m *LicenseKey) XXX_DiscardUnknown() {
	xxx_messageInfo_LicenseKey.DiscardUnknown(m)
}

var xxx_messageInfo_LicenseKey proto.InternalMessageInfo

func (m *LicenseKey) GetLicense() []byte {
	if m != nil {
		return m.License
	}
	return nil
}

func (m *LicenseKey) GetSignatures() []*LicenseKey_Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

type LicenseKey_Signature struct {
	// The ID of the key used to sign license.
	KeyID string `protobuf:"bytes,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	// Signature for license using the key identified by key_id.
	Signature            []byte   `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LicenseKey_Signature) Reset()      { *m = LicenseKey_Signature{} }
func (*LicenseKey_Signature) ProtoMessage() {}
func (*LicenseKey_Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_09ba50819c0c2e19, []int{3, 0}
}
func (m *LicenseKey_Signature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LicenseKey_Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LicenseKey_Signature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LicenseKey_Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LicenseKey_Signature.Merge(m, src)
}
func (m *LicenseKey_Signature) XXX_Size() int {
	return m.Size()
}
func (m *LicenseKey_Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_LicenseKey_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_LicenseKey_Signature proto.InternalMessageInfo

func (m *LicenseKey_Signature) GetKeyID() string {
	if m != nil {
		return m.KeyID
	}
	return ""
}

func (m *LicenseKey_Signature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type MeteringData struct {
	Tenants              []*MeteringData_TenantMeteringData `protobuf:"bytes,1,rep,name=tenants,proto3" json:"tenants,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *MeteringData) Reset()      { *m = MeteringData{} }
func (*MeteringData) ProtoMessage() {}
func (*MeteringData) Descriptor() ([]byte, []int) {
	return fileDescriptor_09ba50819c0c2e19, []int{4}
}
func (m *MeteringData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeteringData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeteringData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeteringData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeteringData.Merge(m, src)
}
func (m *MeteringData) XXX_Size() int {
	return m.Size()
}
func (m *MeteringData) XXX_DiscardUnknown() {
	xxx_messageInfo_MeteringData.DiscardUnknown(m)
}

var xxx_messageInfo_MeteringData proto.InternalMessageInfo

func (m *MeteringData) GetTenants() []*MeteringData_TenantMeteringData {
	if m != nil {
		return m.Tenants
	}
	return nil
}

type MeteringData_TenantMeteringData struct {
	TenantIdentifiers    `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3,embedded=tenant_id" json:"tenant_id"`
	Totals               *TenantRegistryTotals `protobuf:"bytes,2,opt,name=totals,proto3" json:"totals,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MeteringData_TenantMeteringData) Reset()      { *m = MeteringData_TenantMeteringData{} }
func (*MeteringData_TenantMeteringData) ProtoMessage() {}
func (*MeteringData_TenantMeteringData) Descriptor() ([]byte, []int) {
	return fileDescriptor_09ba50819c0c2e19, []int{4, 0}
}
func (m *MeteringData_TenantMeteringData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeteringData_TenantMeteringData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeteringData_TenantMeteringData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeteringData_TenantMeteringData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeteringData_TenantMeteringData.Merge(m, src)
}
func (m *MeteringData_TenantMeteringData) XXX_Size() int {
	return m.Size()
}
func (m *MeteringData_TenantMeteringData) XXX_DiscardUnknown() {
	xxx_messageInfo_MeteringData_TenantMeteringData.DiscardUnknown(m)
}

var xxx_messageInfo_MeteringData_TenantMeteringData proto.InternalMessageInfo

func (m *MeteringData_TenantMeteringData) GetTotals() *TenantRegistryTotals {
	if m != nil {
		return m.Totals
	}
	return nil
}

func init() {
	proto.RegisterType((*License)(nil), "tti.lorawan.v3.License")
	golang_proto.RegisterType((*License)(nil), "tti.lorawan.v3.License")
	proto.RegisterType((*LicenseUpdate)(nil), "tti.lorawan.v3.LicenseUpdate")
	golang_proto.RegisterType((*LicenseUpdate)(nil), "tti.lorawan.v3.LicenseUpdate")
	proto.RegisterType((*MeteringConfiguration)(nil), "tti.lorawan.v3.MeteringConfiguration")
	golang_proto.RegisterType((*MeteringConfiguration)(nil), "tti.lorawan.v3.MeteringConfiguration")
	proto.RegisterType((*MeteringConfiguration_AWS)(nil), "tti.lorawan.v3.MeteringConfiguration.AWS")
	golang_proto.RegisterType((*MeteringConfiguration_AWS)(nil), "tti.lorawan.v3.MeteringConfiguration.AWS")
	proto.RegisterType((*LicenseKey)(nil), "tti.lorawan.v3.LicenseKey")
	golang_proto.RegisterType((*LicenseKey)(nil), "tti.lorawan.v3.LicenseKey")
	proto.RegisterType((*LicenseKey_Signature)(nil), "tti.lorawan.v3.LicenseKey.Signature")
	golang_proto.RegisterType((*LicenseKey_Signature)(nil), "tti.lorawan.v3.LicenseKey.Signature")
	proto.RegisterType((*MeteringData)(nil), "tti.lorawan.v3.MeteringData")
	golang_proto.RegisterType((*MeteringData)(nil), "tti.lorawan.v3.MeteringData")
	proto.RegisterType((*MeteringData_TenantMeteringData)(nil), "tti.lorawan.v3.MeteringData.TenantMeteringData")
	golang_proto.RegisterType((*MeteringData_TenantMeteringData)(nil), "tti.lorawan.v3.MeteringData.TenantMeteringData")
}

func init() {
	proto.RegisterFile("lorawan-stack/api/tti/license.proto", fileDescriptor_09ba50819c0c2e19)
}
func init() {
	golang_proto.RegisterFile("lorawan-stack/api/tti/license.proto", fileDescriptor_09ba50819c0c2e19)
}

var fileDescriptor_09ba50819c0c2e19 = []byte{
	// 1275 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x96, 0x41, 0x6c, 0x13, 0x47,
	0x17, 0xc7, 0x77, 0x62, 0x92, 0xd8, 0x93, 0x84, 0x24, 0xf3, 0x7d, 0xa8, 0x4b, 0x0a, 0x63, 0x37,
	0x50, 0xd5, 0x95, 0x9a, 0xb5, 0x04, 0x08, 0xb5, 0x94, 0x96, 0xc6, 0x71, 0x00, 0x37, 0x45, 0xad,
	0x36, 0x04, 0xa4, 0x1e, 0xba, 0x9a, 0x78, 0x27, 0x9b, 0x69, 0xbc, 0x33, 0xab, 0x9d, 0x59, 0xc7,
	0xee, 0xa5, 0x1c, 0x51, 0xd5, 0x03, 0x47, 0x0e, 0x3d, 0x54, 0x3d, 0x71, 0xe4, 0x52, 0x89, 0xde,
	0x38, 0x72, 0xe4, 0x88, 0x7a, 0x48, 0xf1, 0xfa, 0xc2, 0x91, 0x23, 0xea, 0xa9, 0xda, 0xd9, 0xb5,
	0x63, 0x48, 0xd2, 0x9a, 0x9b, 0x67, 0xde, 0xff, 0xff, 0x7b, 0x33, 0x6f, 0x66, 0xdf, 0x18, 0x9e,
	0x69, 0x8a, 0x90, 0xec, 0x12, 0xbe, 0x24, 0x15, 0x69, 0xec, 0x54, 0x48, 0xc0, 0x2a, 0x4a, 0xb1,
	0x4a, 0x93, 0x35, 0x28, 0x97, 0xd4, 0x0a, 0x42, 0xa1, 0x04, 0x3a, 0xae, 0x14, 0xb3, 0x32, 0xa1,
	0xd5, 0x3a, 0xbf, 0xb0, 0xec, 0x31, 0xb5, 0x1d, 0x6d, 0x5a, 0x0d, 0xe1, 0x57, 0x28, 0x6f, 0x89,
	0x4e, 0x10, 0x8a, 0x76, 0xa7, 0xa2, 0xc5, 0x8d, 0x25, 0x8f, 0xf2, 0xa5, 0x16, 0x69, 0x32, 0x97,
	0x28, 0x5a, 0x39, 0xf0, 0x23, 0x45, 0x2e, 0x2c, 0x0d, 0x21, 0x3c, 0xe1, 0x89, 0xd4, 0xbc, 0x19,
	0x6d, 0xe9, 0x91, 0x1e, 0xe8, 0x5f, 0x99, 0x1c, 0x7b, 0x42, 0x78, 0x4d, 0xba, 0xaf, 0x72, 0xa3,
	0x90, 0x28, 0x26, 0x78, 0x16, 0x2f, 0xbe, 0x19, 0x57, 0xcc, 0xa7, 0x52, 0x11, 0x3f, 0x38, 0x0a,
	0xb0, 0x1b, 0x92, 0x20, 0xa0, 0xa1, 0xcc, 0xe2, 0xa7, 0x0f, 0xd6, 0x81, 0xf2, 0xc8, 0xef, 0x87,
	0x3f, 0x38, 0xbc, 0x4c, 0xcc, 0xa5, 0x5c, 0xb1, 0x2d, 0xb6, 0xcf, 0x59, 0x3c, 0x5c, 0xa8, 0x28,
	0x27, 0x5c, 0xa5, 0x9a, 0xc5, 0xdf, 0xa7, 0xe0, 0xe4, 0x57, 0x69, 0x81, 0x51, 0x0d, 0x8e, 0x31,
	0xd7, 0x04, 0x25, 0x50, 0x9e, 0x3a, 0xb7, 0x68, 0xbd, 0x5e, 0x67, 0x2b, 0x13, 0xd5, 0xf7, 0xb3,
	0x54, 0xe7, 0xfe, 0xae, 0x8e, 0xff, 0x04, 0xc6, 0xe6, 0xc0, 0x93, 0xbd, 0xa2, 0xf1, 0x74, 0xaf,
	0x08, 0xec, 0x31, 0xe6, 0xa2, 0x6d, 0x88, 0xb2, 0x13, 0x73, 0x98, 0x94, 0x11, 0x0d, 0x1d, 0xe6,
	0x4a, 0x73, 0x4c, 0x53, 0xcb, 0x47, 0x51, 0xb5, 0xf0, 0xdf, 0xd9, 0x73, 0xcd, 0xd7, 0xb5, 0x12,
	0xad, 0x40, 0xd8, 0x08, 0x29, 0x51, 0xd4, 0x75, 0x88, 0x32, 0x73, 0x3a, 0xc3, 0x82, 0x95, 0x16,
	0xd7, 0xea, 0x17, 0xd7, 0xba, 0xd9, 0xaf, 0x7e, 0x35, 0x9f, 0xb0, 0xee, 0xfd, 0x55, 0x04, 0x76,
	0x21, 0xf3, 0x2d, 0xab, 0x04, 0xa2, 0xaf, 0x83, 0xb3, 0x15, 0x0a, 0xdf, 0x3c, 0xf6, 0x36, 0x10,
	0xed, 0xbb, 0x1a, 0x0a, 0x1f, 0xad, 0xc2, 0xa9, 0x14, 0x12, 0x71, 0xc5, 0x9a, 0xe6, 0xf8, 0x5b,
	0x50, 0xd2, 0xec, 0x1b, 0x89, 0x0f, 0x7d, 0x0e, 0xf3, 0xbb, 0x24, 0xe4, 0xce, 0x96, 0x08, 0xcd,
	0x09, 0xcd, 0x38, 0x79, 0x80, 0x51, 0xcb, 0x2e, 0x5b, 0x8a, 0xb8, 0x9f, 0x20, 0x26, 0x13, 0xd3,
	0x55, 0x11, 0xa2, 0x2f, 0x60, 0xa1, 0xc9, 0x7c, 0xa6, 0x34, 0x60, 0x72, 0x74, 0x40, 0x5e, 0xbb,
	0x12, 0x42, 0x11, 0x4e, 0xf9, 0x8c, 0x3b, 0x2d, 0x1a, 0x4a, 0x26, 0xb8, 0x99, 0x2f, 0x81, 0x72,
	0xc1, 0x86, 0x3e, 0xe3, 0xb7, 0xd2, 0x19, 0x2d, 0x20, 0xed, 0x81, 0xa0, 0x90, 0x09, 0x48, 0xbb,
	0x2f, 0xf8, 0x14, 0xc2, 0x86, 0xf0, 0x03, 0xc1, 0x29, 0x57, 0xd2, 0x84, 0xa5, 0x5c, 0xf9, 0xf8,
	0xb9, 0x77, 0x2d, 0xa5, 0xf8, 0xf0, 0xb1, 0xaf, 0x34, 0x23, 0xa9, 0x68, 0x68, 0x8b, 0x26, 0xb5,
	0x87, 0xe4, 0xe8, 0x12, 0x3c, 0x39, 0x18, 0x39, 0xc4, 0x75, 0x43, 0x2a, 0xa5, 0x13, 0x52, 0x8f,
	0xb6, 0x03, 0x69, 0x4e, 0x95, 0x72, 0xe5, 0x82, 0xfd, 0xce, 0x40, 0xb0, 0x9c, 0xc6, 0xed, 0x34,
	0x8c, 0x38, 0x9c, 0x77, 0x69, 0x4b, 0xbb, 0x9c, 0x20, 0xa4, 0x5b, 0xac, 0x4d, 0xa5, 0x39, 0x5d,
	0xca, 0x95, 0xa7, 0xab, 0xd5, 0x64, 0xa7, 0x7f, 0xee, 0x15, 0x2f, 0x79, 0xc2, 0x52, 0xdb, 0x54,
	0x6d, 0x33, 0xee, 0x49, 0x8b, 0x53, 0xb5, 0x2b, 0xc2, 0x9d, 0xca, 0xeb, 0x5f, 0x49, 0xb0, 0xe3,
	0x55, 0x54, 0x27, 0xa0, 0xd2, 0xaa, 0xd1, 0x56, 0x92, 0xe2, 0x1b, 0xcd, 0xb2, 0x67, 0xdd, 0xe1,
	0x21, 0x95, 0xe8, 0x47, 0x38, 0xff, 0xbd, 0x60, 0xdc, 0xa1, 0x11, 0xdb, 0xcf, 0x37, 0xa3, 0xf3,
	0xad, 0x67, 0xf9, 0x3e, 0x7e, 0xab, 0x7c, 0xab, 0x1b, 0xf5, 0x8b, 0x17, 0x52, 0x7c, 0xbc, 0x57,
	0x9c, 0xfd, 0x52, 0x30, 0xbe, 0xba, 0x51, 0xef, 0xe7, 0xb3, 0x67, 0x93, 0x6c, 0xab, 0x11, 0x1b,
	0x2c, 0xe0, 0x0c, 0x9c, 0xf1, 0xa3, 0xa6, 0x62, 0x8e, 0xfe, 0xa0, 0x1b, 0x1d, 0xf3, 0x78, 0x09,
	0x94, 0xf3, 0xf6, 0xb4, 0x9e, 0xbc, 0x99, 0xce, 0xa1, 0x6b, 0x70, 0x2e, 0x39, 0x2f, 0x12, 0x04,
	0x4d, 0xd6, 0xd0, 0xe7, 0x2e, 0xcd, 0x59, 0x7d, 0x33, 0x4e, 0x1d, 0xb8, 0x19, 0x1b, 0x75, 0xae,
	0x2e, 0x5e, 0xb8, 0x45, 0x9a, 0x11, 0xb5, 0x67, 0x7d, 0xd2, 0x5e, 0x1e, 0x32, 0xa1, 0xcf, 0xd2,
	0x83, 0x6f, 0x34, 0x99, 0x3e, 0xd8, 0xb9, 0x11, 0x18, 0xc9, 0xb5, 0x58, 0x49, 0xf5, 0xa8, 0x06,
	0x13, 0xa2, 0x43, 0xb9, 0xeb, 0xb8, 0xb4, 0xc5, 0x1a, 0x54, 0x9a, 0xf3, 0x23, 0x20, 0x66, 0x7c,
	0xd2, 0x5e, 0xe5, 0x6e, 0x2d, 0xb5, 0xa0, 0x2b, 0x70, 0x3a, 0xa1, 0x78, 0x44, 0xd1, 0x5d, 0xd2,
	0x91, 0x26, 0x1a, 0x01, 0x91, 0x2c, 0xfb, 0x5a, 0x66, 0x40, 0x75, 0x38, 0x9f, 0x00, 0x44, 0xe8,
	0x11, 0xce, 0x7e, 0xc8, 0xea, 0xf1, 0xbf, 0x11, 0x28, 0x49, 0x15, 0xbf, 0x1e, 0x76, 0xa1, 0x4f,
	0x60, 0x21, 0x41, 0x45, 0x92, 0x86, 0xd2, 0xfc, 0xff, 0x08, 0x88, 0xbc, 0x4f, 0xda, 0x1b, 0x89,
	0x1a, 0x2d, 0xc3, 0xbc, 0x4f, 0x15, 0x0d, 0x19, 0xf7, 0xcc, 0x13, 0xda, 0xf9, 0xfe, 0x9b, 0x8d,
	0xf1, 0x46, 0x16, 0x5f, 0x11, 0x7c, 0x8b, 0x79, 0xd9, 0x27, 0x6b, 0x0f, 0x6c, 0x8b, 0xdf, 0xc1,
	0x99, 0xac, 0x77, 0x6e, 0x04, 0xc9, 0x53, 0x86, 0x6e, 0x40, 0x44, 0xdb, 0x2a, 0xa9, 0xef, 0x70,
	0x27, 0x02, 0xff, 0xd5, 0x04, 0x8e, 0xe9, 0x06, 0x30, 0x97, 0x5a, 0x6f, 0x0d, 0x5a, 0xd1, 0xe2,
	0xcf, 0x63, 0xf0, 0xc4, 0xa1, 0x6b, 0x40, 0x57, 0x60, 0x9e, 0x71, 0x45, 0xc3, 0x16, 0x19, 0x01,
	0x3f, 0xd4, 0x63, 0xfa, 0x26, 0x74, 0x19, 0x42, 0xc1, 0x1d, 0x19, 0x35, 0x1a, 0x54, 0xf6, 0x1f,
	0x86, 0xd3, 0x47, 0x3c, 0x0c, 0xe9, 0xe6, 0xec, 0x82, 0xe0, 0xeb, 0xa9, 0x1e, 0x5d, 0x85, 0x39,
	0xb2, 0x2b, 0xb3, 0x6e, 0xff, 0xe1, 0x48, 0x65, 0xb3, 0x96, 0x6f, 0xaf, 0x57, 0x27, 0xe3, 0xbd,
	0x62, 0x6e, 0xf9, 0xf6, 0xfa, 0x75, 0xc3, 0x4e, 0x00, 0x0b, 0x25, 0x98, 0x8c, 0xd0, 0x49, 0x98,
	0x93, 0x3b, 0x91, 0xde, 0x48, 0x21, 0xd5, 0xac, 0xaf, 0x6d, 0xd8, 0xc9, 0x5c, 0x15, 0xee, 0x9f,
	0xd2, 0xe2, 0x1f, 0x00, 0xc2, 0x6c, 0x49, 0x6b, 0xb4, 0x83, 0x4c, 0x38, 0x99, 0xbd, 0x46, 0xda,
	0x39, 0x6d, 0xf7, 0x87, 0xa8, 0x06, 0xa1, 0x64, 0x1e, 0x27, 0x2a, 0x0a, 0x69, 0xb2, 0xb9, 0x5c,
	0x79, 0xea, 0xdc, 0xd9, 0x23, 0x36, 0xb7, 0x46, 0x3b, 0xd6, 0x7a, 0x5f, 0x6c, 0x0f, 0xf9, 0x16,
	0xd6, 0x60, 0x61, 0x10, 0x40, 0x25, 0x38, 0xb1, 0x43, 0x3b, 0x4e, 0xf6, 0x34, 0x17, 0xaa, 0x85,
	0x78, 0xaf, 0x38, 0xbe, 0x46, 0x3b, 0xf5, 0x9a, 0x3d, 0xbe, 0x43, 0x3b, 0x75, 0x17, 0x9d, 0x82,
	0x85, 0x81, 0x59, 0x17, 0x74, 0xda, 0xde, 0x9f, 0x58, 0x7c, 0x05, 0xe0, 0x74, 0xbf, 0x2e, 0x35,
	0xa2, 0x08, 0xaa, 0xc3, 0xc9, 0xf4, 0x3f, 0x80, 0x34, 0x81, 0x5e, 0x60, 0xe5, 0xa8, 0x32, 0x26,
	0x72, 0x4b, 0xb7, 0x12, 0x35, 0x3c, 0x65, 0xf7, 0xfd, 0x0b, 0xbf, 0x00, 0x88, 0x0e, 0xc6, 0xd1,
	0x75, 0x58, 0x48, 0x15, 0xce, 0xe0, 0x0f, 0xc5, 0x7b, 0x6f, 0xe6, 0x48, 0x6d, 0xc3, 0x6f, 0x7e,
	0x7e, 0xf0, 0xd6, 0xe7, 0x55, 0x16, 0x44, 0x97, 0xe1, 0x84, 0x12, 0x8a, 0x34, 0xfb, 0x17, 0xe5,
	0xec, 0xe1, 0x18, 0x9b, 0x7a, 0x4c, 0xaa, 0xb0, 0x73, 0x53, 0x6b, 0xed, 0xcc, 0x53, 0xfd, 0x0d,
	0x3c, 0xe9, 0x62, 0xf0, 0xb4, 0x8b, 0xc1, 0xb3, 0x2e, 0x36, 0x9e, 0x77, 0xb1, 0xf1, 0xa2, 0x8b,
	0x8d, 0x97, 0x5d, 0x6c, 0xbc, 0xea, 0x62, 0x70, 0x27, 0xc6, 0xe0, 0x6e, 0x8c, 0x8d, 0x07, 0x31,
	0x06, 0x0f, 0x63, 0x6c, 0x3c, 0x8a, 0xb1, 0xf1, 0x38, 0xc6, 0xc6, 0x93, 0x18, 0x83, 0xa7, 0x31,
	0x06, 0xcf, 0x62, 0x6c, 0x3c, 0x8f, 0x31, 0x78, 0x11, 0x63, 0xe3, 0x65, 0x8c, 0xc1, 0xab, 0x18,
	0x1b, 0x77, 0x7a, 0xd8, 0xb8, 0xdb, 0xc3, 0xe0, 0x5e, 0x0f, 0x1b, 0xf7, 0x7b, 0x18, 0xfc, 0xda,
	0xc3, 0xc6, 0x83, 0x1e, 0x36, 0x1e, 0xf6, 0x30, 0x78, 0xd4, 0xc3, 0xe0, 0x71, 0x0f, 0x83, 0x6f,
	0x3f, 0x1a, 0xb5, 0xef, 0x2b, 0x16, 0x6c, 0x6e, 0x4e, 0xe8, 0xcf, 0xe6, 0xfc, 0x3f, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x37, 0xc8, 0x4f, 0x46, 0xff, 0x0a, 0x00, 0x00,
}

func (this *License) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*License)
	if !ok {
		that2, ok := that.(License)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LicenseIdentifiers.Equal(&that1.LicenseIdentifiers) {
		return false
	}
	if !this.LicenseIssuerIdentifiers.Equal(&that1.LicenseIssuerIdentifiers) {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !this.ValidFrom.Equal(that1.ValidFrom) {
		return false
	}
	if !this.ValidUntil.Equal(that1.ValidUntil) {
		return false
	}
	if this.WarnFor != that1.WarnFor {
		return false
	}
	if this.LimitFor != that1.LimitFor {
		return false
	}
	if this.MinVersion != that1.MinVersion {
		return false
	}
	if this.MaxVersion != that1.MaxVersion {
		return false
	}
	if len(this.Components) != len(that1.Components) {
		return false
	}
	for i := range this.Components {
		if this.Components[i] != that1.Components[i] {
			return false
		}
	}
	if len(this.ComponentAddressRegexps) != len(that1.ComponentAddressRegexps) {
		return false
	}
	for i := range this.ComponentAddressRegexps {
		if this.ComponentAddressRegexps[i] != that1.ComponentAddressRegexps[i] {
			return false
		}
	}
	if len(this.DevAddrPrefixes) != len(that1.DevAddrPrefixes) {
		return false
	}
	for i := range this.DevAddrPrefixes {
		if !this.DevAddrPrefixes[i].Equal(that1.DevAddrPrefixes[i]) {
			return false
		}
	}
	if len(this.JoinEUIPrefixes) != len(that1.JoinEUIPrefixes) {
		return false
	}
	for i := range this.JoinEUIPrefixes {
		if !this.JoinEUIPrefixes[i].Equal(that1.JoinEUIPrefixes[i]) {
			return false
		}
	}
	if this.MultiTenancy != that1.MultiTenancy {
		return false
	}
	if !this.MaxApplications.Equal(that1.MaxApplications) {
		return false
	}
	if !this.MaxClients.Equal(that1.MaxClients) {
		return false
	}
	if !this.MaxEndDevices.Equal(that1.MaxEndDevices) {
		return false
	}
	if !this.MaxGateways.Equal(that1.MaxGateways) {
		return false
	}
	if !this.MaxOrganizations.Equal(that1.MaxOrganizations) {
		return false
	}
	if !this.MaxUsers.Equal(that1.MaxUsers) {
		return false
	}
	if !this.Metering.Equal(that1.Metering) {
		return false
	}
	return true
}
func (this *LicenseUpdate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LicenseUpdate)
	if !ok {
		that2, ok := that.(LicenseUpdate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExtendValidUntil != nil && that1.ExtendValidUntil != nil {
		if *this.ExtendValidUntil != *that1.ExtendValidUntil {
			return false
		}
	} else if this.ExtendValidUntil != nil {
		return false
	} else if that1.ExtendValidUntil != nil {
		return false
	}
	return true
}
func (this *MeteringConfiguration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MeteringConfiguration)
	if !ok {
		that2, ok := that.(MeteringConfiguration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Interval != that1.Interval {
		return false
	}
	if !this.OnSuccess.Equal(that1.OnSuccess) {
		return false
	}
	if that1.Metering == nil {
		if this.Metering != nil {
			return false
		}
	} else if this.Metering == nil {
		return false
	} else if !this.Metering.Equal(that1.Metering) {
		return false
	}
	return true
}
func (this *MeteringConfiguration_AWS_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MeteringConfiguration_AWS_)
	if !ok {
		that2, ok := that.(MeteringConfiguration_AWS_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AWS.Equal(that1.AWS) {
		return false
	}
	return true
}
func (this *MeteringConfiguration_AWS) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MeteringConfiguration_AWS)
	if !ok {
		that2, ok := that.(MeteringConfiguration_AWS)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SKU != that1.SKU {
		return false
	}
	return true
}
func (this *LicenseKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LicenseKey)
	if !ok {
		that2, ok := that.(LicenseKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.License, that1.License) {
		return false
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return false
	}
	for i := range this.Signatures {
		if !this.Signatures[i].Equal(that1.Signatures[i]) {
			return false
		}
	}
	return true
}
func (this *LicenseKey_Signature) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LicenseKey_Signature)
	if !ok {
		that2, ok := that.(LicenseKey_Signature)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.KeyID != that1.KeyID {
		return false
	}
	if !bytes.Equal(this.Signature, that1.Signature) {
		return false
	}
	return true
}
func (this *MeteringData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MeteringData)
	if !ok {
		that2, ok := that.(MeteringData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Tenants) != len(that1.Tenants) {
		return false
	}
	for i := range this.Tenants {
		if !this.Tenants[i].Equal(that1.Tenants[i]) {
			return false
		}
	}
	return true
}
func (this *MeteringData_TenantMeteringData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MeteringData_TenantMeteringData)
	if !ok {
		that2, ok := that.(MeteringData_TenantMeteringData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TenantIdentifiers.Equal(&that1.TenantIdentifiers) {
		return false
	}
	if !this.Totals.Equal(that1.Totals) {
		return false
	}
	return true
}
func (m *License) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *License) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *License) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metering != nil {
		{
			size, err := m.Metering.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLicense(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.MaxUsers != nil {
		{
			size, err := m.MaxUsers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLicense(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.MaxOrganizations != nil {
		{
			size, err := m.MaxOrganizations.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLicense(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.MaxGateways != nil {
		{
			size, err := m.MaxGateways.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLicense(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.MaxEndDevices != nil {
		{
			size, err := m.MaxEndDevices.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLicense(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.MaxClients != nil {
		{
			size, err := m.MaxClients.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLicense(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.MaxApplications != nil {
		{
			size, err := m.MaxApplications.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLicense(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.MultiTenancy {
		i--
		if m.MultiTenancy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if len(m.JoinEUIPrefixes) > 0 {
		for iNdEx := len(m.JoinEUIPrefixes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.JoinEUIPrefixes[iNdEx].Size()
				i -= size
				if _, err := m.JoinEUIPrefixes[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintLicense(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.DevAddrPrefixes) > 0 {
		for iNdEx := len(m.DevAddrPrefixes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.DevAddrPrefixes[iNdEx].Size()
				i -= size
				if _, err := m.DevAddrPrefixes[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintLicense(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.ComponentAddressRegexps) > 0 {
		for iNdEx := len(m.ComponentAddressRegexps) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ComponentAddressRegexps[iNdEx])
			copy(dAtA[i:], m.ComponentAddressRegexps[iNdEx])
			i = encodeVarintLicense(dAtA, i, uint64(len(m.ComponentAddressRegexps[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Components) > 0 {
		dAtA9 := make([]byte, len(m.Components)*10)
		var j8 int
		for _, num := range m.Components {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintLicense(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x52
	}
	if len(m.MaxVersion) > 0 {
		i -= len(m.MaxVersion)
		copy(dAtA[i:], m.MaxVersion)
		i = encodeVarintLicense(dAtA, i, uint64(len(m.MaxVersion)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.MinVersion) > 0 {
		i -= len(m.MinVersion)
		copy(dAtA[i:], m.MinVersion)
		i = encodeVarintLicense(dAtA, i, uint64(len(m.MinVersion)))
		i--
		dAtA[i] = 0x42
	}
	n10, err10 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.LimitFor, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.LimitFor):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintLicense(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0x3a
	n11, err11 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.WarnFor, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.WarnFor):])
	if err11 != nil {
		return 0, err11
	}
	i -= n11
	i = encodeVarintLicense(dAtA, i, uint64(n11))
	i--
	dAtA[i] = 0x32
	n12, err12 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.ValidUntil, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.ValidUntil):])
	if err12 != nil {
		return 0, err12
	}
	i -= n12
	i = encodeVarintLicense(dAtA, i, uint64(n12))
	i--
	dAtA[i] = 0x2a
	n13, err13 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.ValidFrom, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.ValidFrom):])
	if err13 != nil {
		return 0, err13
	}
	i -= n13
	i = encodeVarintLicense(dAtA, i, uint64(n13))
	i--
	dAtA[i] = 0x22
	n14, err14 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedAt):])
	if err14 != nil {
		return 0, err14
	}
	i -= n14
	i = encodeVarintLicense(dAtA, i, uint64(n14))
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.LicenseIssuerIdentifiers.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLicense(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.LicenseIdentifiers.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLicense(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LicenseUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LicenseUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LicenseUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExtendValidUntil != nil {
		n17, err17 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.ExtendValidUntil, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.ExtendValidUntil):])
		if err17 != nil {
			return 0, err17
		}
		i -= n17
		i = encodeVarintLicense(dAtA, i, uint64(n17))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MeteringConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeteringConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeteringConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metering != nil {
		{
			size := m.Metering.Size()
			i -= size
			if _, err := m.Metering.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OnSuccess != nil {
		{
			size, err := m.OnSuccess.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLicense(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	n19, err19 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Interval, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.Interval):])
	if err19 != nil {
		return 0, err19
	}
	i -= n19
	i = encodeVarintLicense(dAtA, i, uint64(n19))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MeteringConfiguration_AWS_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MeteringConfiguration_AWS_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AWS != nil {
		{
			size, err := m.AWS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLicense(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *MeteringConfiguration_AWS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeteringConfiguration_AWS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeteringConfiguration_AWS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SKU) > 0 {
		i -= len(m.SKU)
		copy(dAtA[i:], m.SKU)
		i = encodeVarintLicense(dAtA, i, uint64(len(m.SKU)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LicenseKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LicenseKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LicenseKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLicense(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.License) > 0 {
		i -= len(m.License)
		copy(dAtA[i:], m.License)
		i = encodeVarintLicense(dAtA, i, uint64(len(m.License)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LicenseKey_Signature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LicenseKey_Signature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LicenseKey_Signature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintLicense(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KeyID) > 0 {
		i -= len(m.KeyID)
		copy(dAtA[i:], m.KeyID)
		i = encodeVarintLicense(dAtA, i, uint64(len(m.KeyID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MeteringData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeteringData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeteringData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tenants) > 0 {
		for iNdEx := len(m.Tenants) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tenants[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLicense(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MeteringData_TenantMeteringData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeteringData_TenantMeteringData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeteringData_TenantMeteringData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Totals != nil {
		{
			size, err := m.Totals.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLicense(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.TenantIdentifiers.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLicense(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintLicense(dAtA []byte, offset int, v uint64) int {
	offset -= sovLicense(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedLicense(r randyLicense, easy bool) *License {
	this := &License{}
	v1 := NewPopulatedLicenseIdentifiers(r, easy)
	this.LicenseIdentifiers = *v1
	v2 := NewPopulatedLicenseIssuerIdentifiers(r, easy)
	this.LicenseIssuerIdentifiers = *v2
	v3 := github_com_gogo_protobuf_types.NewPopulatedStdTime(r, easy)
	this.CreatedAt = *v3
	v4 := github_com_gogo_protobuf_types.NewPopulatedStdTime(r, easy)
	this.ValidFrom = *v4
	v5 := github_com_gogo_protobuf_types.NewPopulatedStdTime(r, easy)
	this.ValidUntil = *v5
	v6 := github_com_gogo_protobuf_types.NewPopulatedStdDuration(r, easy)
	this.WarnFor = *v6
	v7 := github_com_gogo_protobuf_types.NewPopulatedStdDuration(r, easy)
	this.LimitFor = *v7
	this.MinVersion = randStringLicense(r)
	this.MaxVersion = randStringLicense(r)
	v8 := r.Intn(10)
	this.Components = make([]ttnpb.ClusterRole, v8)
	for i := 0; i < v8; i++ {
		this.Components[i] = ttnpb.ClusterRole([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}[r.Intn(11)])
	}
	v9 := r.Intn(10)
	this.ComponentAddressRegexps = make([]string, v9)
	for i := 0; i < v9; i++ {
		this.ComponentAddressRegexps[i] = randStringLicense(r)
	}
	v10 := r.Intn(10)
	this.DevAddrPrefixes = make([]go_thethings_network_lorawan_stack_pkg_types.DevAddrPrefix, v10)
	for i := 0; i < v10; i++ {
		v11 := go_thethings_network_lorawan_stack_pkg_types.NewPopulatedDevAddrPrefix(r)
		this.DevAddrPrefixes[i] = *v11
	}
	v12 := r.Intn(10)
	this.JoinEUIPrefixes = make([]go_thethings_network_lorawan_stack_pkg_types.EUI64Prefix, v12)
	for i := 0; i < v12; i++ {
		v13 := go_thethings_network_lorawan_stack_pkg_types.NewPopulatedEUI64Prefix(r)
		this.JoinEUIPrefixes[i] = *v13
	}
	this.MultiTenancy = bool(r.Intn(2) == 0)
	if r.Intn(5) != 0 {
		this.MaxApplications = types.NewPopulatedUInt64Value(r, easy)
	}
	if r.Intn(5) != 0 {
		this.MaxClients = types.NewPopulatedUInt64Value(r, easy)
	}
	if r.Intn(5) != 0 {
		this.MaxEndDevices = types.NewPopulatedUInt64Value(r, easy)
	}
	if r.Intn(5) != 0 {
		this.MaxGateways = types.NewPopulatedUInt64Value(r, easy)
	}
	if r.Intn(5) != 0 {
		this.MaxOrganizations = types.NewPopulatedUInt64Value(r, easy)
	}
	if r.Intn(5) != 0 {
		this.MaxUsers = types.NewPopulatedUInt64Value(r, easy)
	}
	if r.Intn(5) != 0 {
		this.Metering = NewPopulatedMeteringConfiguration(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLicenseUpdate(r randyLicense, easy bool) *LicenseUpdate {
	this := &LicenseUpdate{}
	if r.Intn(5) != 0 {
		this.ExtendValidUntil = github_com_gogo_protobuf_types.NewPopulatedStdDuration(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMeteringConfiguration(r randyLicense, easy bool) *MeteringConfiguration {
	this := &MeteringConfiguration{}
	v14 := github_com_gogo_protobuf_types.NewPopulatedStdDuration(r, easy)
	this.Interval = *v14
	if r.Intn(5) != 0 {
		this.OnSuccess = NewPopulatedLicenseUpdate(r, easy)
	}
	oneofNumber_Metering := []int32{3}[r.Intn(1)]
	switch oneofNumber_Metering {
	case 3:
		this.Metering = NewPopulatedMeteringConfiguration_AWS_(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMeteringConfiguration_AWS_(r randyLicense, easy bool) *MeteringConfiguration_AWS_ {
	this := &MeteringConfiguration_AWS_{}
	this.AWS = NewPopulatedMeteringConfiguration_AWS(r, easy)
	return this
}
func NewPopulatedMeteringConfiguration_AWS(r randyLicense, easy bool) *MeteringConfiguration_AWS {
	this := &MeteringConfiguration_AWS{}
	this.SKU = randStringLicense(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLicenseKey(r randyLicense, easy bool) *LicenseKey {
	this := &LicenseKey{}
	v15 := r.Intn(100)
	this.License = make([]byte, v15)
	for i := 0; i < v15; i++ {
		this.License[i] = byte(r.Intn(256))
	}
	if r.Intn(5) != 0 {
		v16 := r.Intn(5)
		this.Signatures = make([]*LicenseKey_Signature, v16)
		for i := 0; i < v16; i++ {
			this.Signatures[i] = NewPopulatedLicenseKey_Signature(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLicenseKey_Signature(r randyLicense, easy bool) *LicenseKey_Signature {
	this := &LicenseKey_Signature{}
	this.KeyID = randStringLicense(r)
	v17 := r.Intn(100)
	this.Signature = make([]byte, v17)
	for i := 0; i < v17; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMeteringData(r randyLicense, easy bool) *MeteringData {
	this := &MeteringData{}
	if r.Intn(5) != 0 {
		v18 := r.Intn(5)
		this.Tenants = make([]*MeteringData_TenantMeteringData, v18)
		for i := 0; i < v18; i++ {
			this.Tenants[i] = NewPopulatedMeteringData_TenantMeteringData(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMeteringData_TenantMeteringData(r randyLicense, easy bool) *MeteringData_TenantMeteringData {
	this := &MeteringData_TenantMeteringData{}
	v19 := NewPopulatedTenantIdentifiers(r, easy)
	this.TenantIdentifiers = *v19
	if r.Intn(5) != 0 {
		this.Totals = NewPopulatedTenantRegistryTotals(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyLicense interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneLicense(r randyLicense) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringLicense(r randyLicense) string {
	v20 := r.Intn(100)
	tmps := make([]rune, v20)
	for i := 0; i < v20; i++ {
		tmps[i] = randUTF8RuneLicense(r)
	}
	return string(tmps)
}
func randUnrecognizedLicense(r randyLicense, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldLicense(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldLicense(dAtA []byte, r randyLicense, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateLicense(dAtA, uint64(key))
		v21 := r.Int63()
		if r.Intn(2) == 0 {
			v21 *= -1
		}
		dAtA = encodeVarintPopulateLicense(dAtA, uint64(v21))
	case 1:
		dAtA = encodeVarintPopulateLicense(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateLicense(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateLicense(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateLicense(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateLicense(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(v&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *License) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.LicenseIdentifiers.Size()
	n += 1 + l + sovLicense(uint64(l))
	l = m.LicenseIssuerIdentifiers.Size()
	n += 1 + l + sovLicense(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovLicense(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.ValidFrom)
	n += 1 + l + sovLicense(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.ValidUntil)
	n += 1 + l + sovLicense(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.WarnFor)
	n += 1 + l + sovLicense(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.LimitFor)
	n += 1 + l + sovLicense(uint64(l))
	l = len(m.MinVersion)
	if l > 0 {
		n += 1 + l + sovLicense(uint64(l))
	}
	l = len(m.MaxVersion)
	if l > 0 {
		n += 1 + l + sovLicense(uint64(l))
	}
	if len(m.Components) > 0 {
		l = 0
		for _, e := range m.Components {
			l += sovLicense(uint64(e))
		}
		n += 1 + sovLicense(uint64(l)) + l
	}
	if len(m.ComponentAddressRegexps) > 0 {
		for _, s := range m.ComponentAddressRegexps {
			l = len(s)
			n += 1 + l + sovLicense(uint64(l))
		}
	}
	if len(m.DevAddrPrefixes) > 0 {
		for _, e := range m.DevAddrPrefixes {
			l = e.Size()
			n += 1 + l + sovLicense(uint64(l))
		}
	}
	if len(m.JoinEUIPrefixes) > 0 {
		for _, e := range m.JoinEUIPrefixes {
			l = e.Size()
			n += 1 + l + sovLicense(uint64(l))
		}
	}
	if m.MultiTenancy {
		n += 2
	}
	if m.MaxApplications != nil {
		l = m.MaxApplications.Size()
		n += 1 + l + sovLicense(uint64(l))
	}
	if m.MaxClients != nil {
		l = m.MaxClients.Size()
		n += 2 + l + sovLicense(uint64(l))
	}
	if m.MaxEndDevices != nil {
		l = m.MaxEndDevices.Size()
		n += 2 + l + sovLicense(uint64(l))
	}
	if m.MaxGateways != nil {
		l = m.MaxGateways.Size()
		n += 2 + l + sovLicense(uint64(l))
	}
	if m.MaxOrganizations != nil {
		l = m.MaxOrganizations.Size()
		n += 2 + l + sovLicense(uint64(l))
	}
	if m.MaxUsers != nil {
		l = m.MaxUsers.Size()
		n += 2 + l + sovLicense(uint64(l))
	}
	if m.Metering != nil {
		l = m.Metering.Size()
		n += 2 + l + sovLicense(uint64(l))
	}
	return n
}

func (m *LicenseUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExtendValidUntil != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.ExtendValidUntil)
		n += 1 + l + sovLicense(uint64(l))
	}
	return n
}

func (m *MeteringConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Interval)
	n += 1 + l + sovLicense(uint64(l))
	if m.OnSuccess != nil {
		l = m.OnSuccess.Size()
		n += 1 + l + sovLicense(uint64(l))
	}
	if m.Metering != nil {
		n += m.Metering.Size()
	}
	return n
}

func (m *MeteringConfiguration_AWS_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AWS != nil {
		l = m.AWS.Size()
		n += 1 + l + sovLicense(uint64(l))
	}
	return n
}
func (m *MeteringConfiguration_AWS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SKU)
	if l > 0 {
		n += 1 + l + sovLicense(uint64(l))
	}
	return n
}

func (m *LicenseKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.License)
	if l > 0 {
		n += 1 + l + sovLicense(uint64(l))
	}
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovLicense(uint64(l))
		}
	}
	return n
}

func (m *LicenseKey_Signature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyID)
	if l > 0 {
		n += 1 + l + sovLicense(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovLicense(uint64(l))
	}
	return n
}

func (m *MeteringData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tenants) > 0 {
		for _, e := range m.Tenants {
			l = e.Size()
			n += 1 + l + sovLicense(uint64(l))
		}
	}
	return n
}

func (m *MeteringData_TenantMeteringData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TenantIdentifiers.Size()
	n += 1 + l + sovLicense(uint64(l))
	if m.Totals != nil {
		l = m.Totals.Size()
		n += 1 + l + sovLicense(uint64(l))
	}
	return n
}

func sovLicense(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLicense(x uint64) (n int) {
	return sovLicense((x << 1) ^ uint64((int64(x) >> 63)))
}
func (this *License) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&License{`,
		`LicenseIdentifiers:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.LicenseIdentifiers), "LicenseIdentifiers", "LicenseIdentifiers", 1), `&`, ``, 1) + `,`,
		`LicenseIssuerIdentifiers:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.LicenseIssuerIdentifiers), "LicenseIssuerIdentifiers", "LicenseIssuerIdentifiers", 1), `&`, ``, 1) + `,`,
		`CreatedAt:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "types.Timestamp", 1), `&`, ``, 1) + `,`,
		`ValidFrom:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ValidFrom), "Timestamp", "types.Timestamp", 1), `&`, ``, 1) + `,`,
		`ValidUntil:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ValidUntil), "Timestamp", "types.Timestamp", 1), `&`, ``, 1) + `,`,
		`WarnFor:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.WarnFor), "Duration", "types.Duration", 1), `&`, ``, 1) + `,`,
		`LimitFor:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.LimitFor), "Duration", "types.Duration", 1), `&`, ``, 1) + `,`,
		`MinVersion:` + fmt.Sprintf("%v", this.MinVersion) + `,`,
		`MaxVersion:` + fmt.Sprintf("%v", this.MaxVersion) + `,`,
		`Components:` + fmt.Sprintf("%v", this.Components) + `,`,
		`ComponentAddressRegexps:` + fmt.Sprintf("%v", this.ComponentAddressRegexps) + `,`,
		`DevAddrPrefixes:` + fmt.Sprintf("%v", this.DevAddrPrefixes) + `,`,
		`JoinEUIPrefixes:` + fmt.Sprintf("%v", this.JoinEUIPrefixes) + `,`,
		`MultiTenancy:` + fmt.Sprintf("%v", this.MultiTenancy) + `,`,
		`MaxApplications:` + strings.Replace(fmt.Sprintf("%v", this.MaxApplications), "UInt64Value", "types.UInt64Value", 1) + `,`,
		`MaxClients:` + strings.Replace(fmt.Sprintf("%v", this.MaxClients), "UInt64Value", "types.UInt64Value", 1) + `,`,
		`MaxEndDevices:` + strings.Replace(fmt.Sprintf("%v", this.MaxEndDevices), "UInt64Value", "types.UInt64Value", 1) + `,`,
		`MaxGateways:` + strings.Replace(fmt.Sprintf("%v", this.MaxGateways), "UInt64Value", "types.UInt64Value", 1) + `,`,
		`MaxOrganizations:` + strings.Replace(fmt.Sprintf("%v", this.MaxOrganizations), "UInt64Value", "types.UInt64Value", 1) + `,`,
		`MaxUsers:` + strings.Replace(fmt.Sprintf("%v", this.MaxUsers), "UInt64Value", "types.UInt64Value", 1) + `,`,
		`Metering:` + strings.Replace(this.Metering.String(), "MeteringConfiguration", "MeteringConfiguration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LicenseUpdate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LicenseUpdate{`,
		`ExtendValidUntil:` + strings.Replace(fmt.Sprintf("%v", this.ExtendValidUntil), "Duration", "types.Duration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MeteringConfiguration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MeteringConfiguration{`,
		`Interval:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Interval), "Duration", "types.Duration", 1), `&`, ``, 1) + `,`,
		`OnSuccess:` + strings.Replace(this.OnSuccess.String(), "LicenseUpdate", "LicenseUpdate", 1) + `,`,
		`Metering:` + fmt.Sprintf("%v", this.Metering) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MeteringConfiguration_AWS_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MeteringConfiguration_AWS_{`,
		`AWS:` + strings.Replace(fmt.Sprintf("%v", this.AWS), "MeteringConfiguration_AWS", "MeteringConfiguration_AWS", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MeteringConfiguration_AWS) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MeteringConfiguration_AWS{`,
		`SKU:` + fmt.Sprintf("%v", this.SKU) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LicenseKey) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSignatures := "[]*LicenseKey_Signature{"
	for _, f := range this.Signatures {
		repeatedStringForSignatures += strings.Replace(fmt.Sprintf("%v", f), "LicenseKey_Signature", "LicenseKey_Signature", 1) + ","
	}
	repeatedStringForSignatures += "}"
	s := strings.Join([]string{`&LicenseKey{`,
		`License:` + fmt.Sprintf("%v", this.License) + `,`,
		`Signatures:` + repeatedStringForSignatures + `,`,
		`}`,
	}, "")
	return s
}
func (this *LicenseKey_Signature) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LicenseKey_Signature{`,
		`KeyID:` + fmt.Sprintf("%v", this.KeyID) + `,`,
		`Signature:` + fmt.Sprintf("%v", this.Signature) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MeteringData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTenants := "[]*MeteringData_TenantMeteringData{"
	for _, f := range this.Tenants {
		repeatedStringForTenants += strings.Replace(fmt.Sprintf("%v", f), "MeteringData_TenantMeteringData", "MeteringData_TenantMeteringData", 1) + ","
	}
	repeatedStringForTenants += "}"
	s := strings.Join([]string{`&MeteringData{`,
		`Tenants:` + repeatedStringForTenants + `,`,
		`}`,
	}, "")
	return s
}
func (this *MeteringData_TenantMeteringData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MeteringData_TenantMeteringData{`,
		`TenantIdentifiers:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.TenantIdentifiers), "TenantIdentifiers", "TenantIdentifiers", 1), `&`, ``, 1) + `,`,
		`Totals:` + strings.Replace(fmt.Sprintf("%v", this.Totals), "TenantRegistryTotals", "TenantRegistryTotals", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringLicense(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *License) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLicense
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: License: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: License: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LicenseIdentifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LicenseIdentifiers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LicenseIssuerIdentifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LicenseIssuerIdentifiers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.ValidFrom, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidUntil", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.ValidUntil, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarnFor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.WarnFor, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitFor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.LimitFor, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v ttnpb.ClusterRole
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLicense
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ttnpb.ClusterRole(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Components = append(m.Components, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLicense
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLicense
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthLicense
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Components) == 0 {
					m.Components = make([]ttnpb.ClusterRole, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ttnpb.ClusterRole
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLicense
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ttnpb.ClusterRole(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Components = append(m.Components, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComponentAddressRegexps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ComponentAddressRegexps = append(m.ComponentAddressRegexps, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevAddrPrefixes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v go_thethings_network_lorawan_stack_pkg_types.DevAddrPrefix
			m.DevAddrPrefixes = append(m.DevAddrPrefixes, v)
			if err := m.DevAddrPrefixes[len(m.DevAddrPrefixes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinEUIPrefixes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v go_thethings_network_lorawan_stack_pkg_types.EUI64Prefix
			m.JoinEUIPrefixes = append(m.JoinEUIPrefixes, v)
			if err := m.JoinEUIPrefixes[len(m.JoinEUIPrefixes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiTenancy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MultiTenancy = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxApplications", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxApplications == nil {
				m.MaxApplications = &types.UInt64Value{}
			}
			if err := m.MaxApplications.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxClients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxClients == nil {
				m.MaxClients = &types.UInt64Value{}
			}
			if err := m.MaxClients.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEndDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxEndDevices == nil {
				m.MaxEndDevices = &types.UInt64Value{}
			}
			if err := m.MaxEndDevices.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxGateways", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxGateways == nil {
				m.MaxGateways = &types.UInt64Value{}
			}
			if err := m.MaxGateways.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxOrganizations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxOrganizations == nil {
				m.MaxOrganizations = &types.UInt64Value{}
			}
			if err := m.MaxOrganizations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUsers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxUsers == nil {
				m.MaxUsers = &types.UInt64Value{}
			}
			if err := m.MaxUsers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metering == nil {
				m.Metering = &MeteringConfiguration{}
			}
			if err := m.Metering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLicense(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLicense
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLicense
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LicenseUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLicense
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LicenseUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LicenseUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendValidUntil", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtendValidUntil == nil {
				m.ExtendValidUntil = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.ExtendValidUntil, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLicense(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLicense
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLicense
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeteringConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLicense
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeteringConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeteringConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Interval, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnSuccess", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnSuccess == nil {
				m.OnSuccess = &LicenseUpdate{}
			}
			if err := m.OnSuccess.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MeteringConfiguration_AWS{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Metering = &MeteringConfiguration_AWS_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLicense(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLicense
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLicense
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeteringConfiguration_AWS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLicense
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SKU", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SKU = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLicense(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLicense
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLicense
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LicenseKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLicense
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LicenseKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LicenseKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field License", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.License = append(m.License[:0], dAtA[iNdEx:postIndex]...)
			if m.License == nil {
				m.License = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, &LicenseKey_Signature{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLicense(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLicense
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLicense
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LicenseKey_Signature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLicense
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLicense(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLicense
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLicense
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeteringData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLicense
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeteringData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeteringData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenants = append(m.Tenants, &MeteringData_TenantMeteringData{})
			if err := m.Tenants[len(m.Tenants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLicense(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLicense
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLicense
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeteringData_TenantMeteringData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLicense
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TenantMeteringData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TenantMeteringData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantIdentifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TenantIdentifiers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Totals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLicense
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLicense
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Totals == nil {
				m.Totals = &TenantRegistryTotals{}
			}
			if err := m.Totals.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLicense(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLicense
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLicense
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLicense(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLicense
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLicense
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLicense
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthLicense
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLicense
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLicense(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthLicense
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLicense = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLicense   = fmt.Errorf("proto: integer overflow")
)
