// Code generated by protoc-gen-fieldmask. DO NOT EDIT.

package ttipb

import (
	fmt "fmt"
	time "time"
)

func (dst *License) SetFields(src *License, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "id":
			if len(subs) > 0 {
				newDst := &dst.LicenseIdentifiers
				var newSrc *LicenseIdentifiers
				if src != nil {
					newSrc = &src.LicenseIdentifiers
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.LicenseIdentifiers = src.LicenseIdentifiers
				} else {
					var zero LicenseIdentifiers
					dst.LicenseIdentifiers = zero
				}
			}
		case "license_issuer_ids":
			if len(subs) > 0 {
				newDst := &dst.LicenseIssuerIdentifiers
				var newSrc *LicenseIssuerIdentifiers
				if src != nil {
					newSrc = &src.LicenseIssuerIdentifiers
				}
				if err := newDst.SetFields(newSrc, subs...); err != nil {
					return err
				}
			} else {
				if src != nil {
					dst.LicenseIssuerIdentifiers = src.LicenseIssuerIdentifiers
				} else {
					var zero LicenseIssuerIdentifiers
					dst.LicenseIssuerIdentifiers = zero
				}
			}
		case "created_at":
			if len(subs) > 0 {
				return fmt.Errorf("'created_at' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.CreatedAt = src.CreatedAt
			} else {
				var zero time.Time
				dst.CreatedAt = zero
			}
		case "valid_from":
			if len(subs) > 0 {
				return fmt.Errorf("'valid_from' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ValidFrom = src.ValidFrom
			} else {
				var zero time.Time
				dst.ValidFrom = zero
			}
		case "valid_until":
			if len(subs) > 0 {
				return fmt.Errorf("'valid_until' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.ValidUntil = src.ValidUntil
			} else {
				var zero time.Time
				dst.ValidUntil = zero
			}
		case "warn_for":
			if len(subs) > 0 {
				return fmt.Errorf("'warn_for' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.WarnFor = src.WarnFor
			} else {
				var zero time.Duration
				dst.WarnFor = zero
			}
		case "limit_for":
			if len(subs) > 0 {
				return fmt.Errorf("'limit_for' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.LimitFor = src.LimitFor
			} else {
				var zero time.Duration
				dst.LimitFor = zero
			}
		case "components":
			if len(subs) > 0 {
				return fmt.Errorf("'components' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Components = src.Components
			} else {
				dst.Components = nil
			}
		case "address_regexps":
			if len(subs) > 0 {
				return fmt.Errorf("'address_regexps' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.AddressRegexps = src.AddressRegexps
			} else {
				dst.AddressRegexps = nil
			}
		case "dev_addr_prefixes":
			if len(subs) > 0 {
				return fmt.Errorf("'dev_addr_prefixes' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.DevAddrPrefixes = src.DevAddrPrefixes
			} else {
				dst.DevAddrPrefixes = nil
			}
		case "join_eui_prefixes":
			if len(subs) > 0 {
				return fmt.Errorf("'join_eui_prefixes' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.JoinEuiPrefixes = src.JoinEuiPrefixes
			} else {
				dst.JoinEuiPrefixes = nil
			}
		case "multi_tenancy":
			if len(subs) > 0 {
				return fmt.Errorf("'multi_tenancy' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.MultiTenancy = src.MultiTenancy
			} else {
				var zero bool
				dst.MultiTenancy = zero
			}
		case "max_applications":
			if len(subs) > 0 {
				return fmt.Errorf("'max_applications' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.MaxApplications = src.MaxApplications
			} else {
				dst.MaxApplications = nil
			}
		case "max_clients":
			if len(subs) > 0 {
				return fmt.Errorf("'max_clients' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.MaxClients = src.MaxClients
			} else {
				dst.MaxClients = nil
			}
		case "max_end_devices":
			if len(subs) > 0 {
				return fmt.Errorf("'max_end_devices' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.MaxEndDevices = src.MaxEndDevices
			} else {
				dst.MaxEndDevices = nil
			}
		case "max_gateways":
			if len(subs) > 0 {
				return fmt.Errorf("'max_gateways' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.MaxGateways = src.MaxGateways
			} else {
				dst.MaxGateways = nil
			}
		case "max_organizations":
			if len(subs) > 0 {
				return fmt.Errorf("'max_organizations' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.MaxOrganizations = src.MaxOrganizations
			} else {
				dst.MaxOrganizations = nil
			}
		case "max_users":
			if len(subs) > 0 {
				return fmt.Errorf("'max_users' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.MaxUsers = src.MaxUsers
			} else {
				dst.MaxUsers = nil
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *LicenseKey) SetFields(src *LicenseKey, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "license":
			if len(subs) > 0 {
				return fmt.Errorf("'license' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.License = src.License
			} else {
				dst.License = nil
			}
		case "signatures":
			if len(subs) > 0 {
				return fmt.Errorf("'signatures' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Signatures = src.Signatures
			} else {
				dst.Signatures = nil
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}

func (dst *LicenseKey_Signature) SetFields(src *LicenseKey_Signature, paths ...string) error {
	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		switch name {
		case "key_id":
			if len(subs) > 0 {
				return fmt.Errorf("'key_id' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.KeyID = src.KeyID
			} else {
				var zero string
				dst.KeyID = zero
			}
		case "signature":
			if len(subs) > 0 {
				return fmt.Errorf("'signature' has no subfields, but %s were specified", subs)
			}
			if src != nil {
				dst.Signature = src.Signature
			} else {
				dst.Signature = nil
			}

		default:
			return fmt.Errorf("invalid field: '%s'", name)
		}
	}
	return nil
}
